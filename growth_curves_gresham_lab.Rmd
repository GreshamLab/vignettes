---
title: "Growth curve analysis using the Tecan 96-well plate reader"
author: "Grace Avecilla and David Gresham"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output: html_notebook
---

This vignette illustrates the use of [code](https://github.com/GreshamLab/tecantools) generated by Grace Avecilla  to analyze 96 well growth curve data generated using our Tecan plate reader.

The workflow uses the `Growthcurver` [package](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-016-1016-7) and is based on part on the Growthcurver [vignette](https://cran.r-project.org/web/packages/growthcurver/vignettes/Growthcurver-vignette.html).

The experiment below includes:

* S. cerevisiae grown in YPD
* S. cerevisiae grown in Glutamine-limited media
* C. albicans grown in YPD
* C. albicans grown in Glutamine-limited media

The data comprise 283 OD measurements that were acquired over a 24 hour period.

* The .csv containing the OD data can be found [here](https://github.com/GreshamLab/vignettes/blob/master/David_Ina_OD_mCit_YPD_Glnlim_11012022-001.csv)
* The .csv containing the samplesheet information can be found [here](https://github.com/GreshamLab/vignettes/blob/master/samplesheet.csv)

# Growth curves requirements

We performed 3 technical replicates per biological replicate using a total of six biological replicates in two different growth conditions.

We set the number of cycles to 530, which ends up being just over 48 hours, but ended the run after 24 hours because it was clear that all cultures had reached stationary phase.  This resulted in a total of 283 OD measurements. 

We also measured GFP at each time point, but these data were not included in the analysis.

Before running the analysis we formatted data as follows:

* OD data from the Tecan in a csv with each well's data in a column, the first row contained the well names, and the first column is time stamps in seconds 

* A sample sheet, with the _four_ required columns: <Well>, <Sample>,	<Bio_rep>,	<Tech_rep>
  + The Well column did not have 0s in the well names (i.e. A1, not A01)
  + An additional column - <Species> - after Tech_rep which will be output as well metadata with the growth curve information 9an abritrary number of columns can be added)
  + For blank wells, we put 'B' in the Sample column of the sample sheet
  + For blank wells, we put 'NA' for all other column values
  
# Set up the file paths and names 
This step defines the files that will be read in, the output files, the number of measurements made during the experiment and the well in which the blank(s) is located.
```{r}
# Path to directory with csv with OD data and sample sheet - put the last / after
filepath = '/Volumes/GoogleDrive/My Drive/Gresham Lab_David/Tecan/'
# sample sheet file name
s_sheet = 'samplesheet.csv'
# data csv
data_file = 'ODonly_David_Ina_OD_mCit_YPD_Glnlim_11012022-001.csv'
# specific the number of cycles
cycles = 283
# output csv name
out = 'output.csv'
```

# Load libraries
We use `growthcurver` for analysis and `tidyverse` for data manipulation and plotting. 
```{r include=T }
knitr::opts_chunk$set(fig.height=6, fig.width=5,
                      cache=TRUE, autodep = TRUE, cache.path = 'facet-rep-labels/')
library(tidyverse)
library(growthcurver)
setwd(filepath)
theme_set(theme_minimal())
```

# Read in sample sheet and data

In this step we fix the name of the time column and convert time from seconds to hours.  We read in the samplesheet and OD measurements and confirm that they are organized correctly.
```{r include=T, eval = T}
samplesheet = read_csv(paste0(filepath, s_sheet))
knitr::kable(samplesheet)

#remove s from time and convert to numeric, divide by 60 2x to go from seconds to hours
data_od = read_csv(paste0(filepath,data_file), 
                   skip = 0, n_max = cycles) 
colnames(data_od)[1] <- "time"
data_od$time <- as.numeric(str_remove(data_od$time,"s"))/60/60

knitr::kable(data_od)
```


# Plot the OD for all wells

## Arranged by biological replicate

Here we visualize each biological replicate. This allows us to assess the agreement between technical and biological replicates.

```{r}
data_od_for_plot <- data_od %>% 
  pivot_longer(cols = -time, names_to = "well", values_to = "od") %>% 
  left_join(samplesheet, by = c("well" = "Well")) %>%
  unite(Sample_Well, well, Sample, sep = " ", remove = FALSE)

# check wells with samples
ggplot(data_od_for_plot %>% filter(Sample != "B"), aes(time, od, color = as.factor(Tech_rep))) +
  geom_line() +
  facet_grid(Sample~Bio_rep) +
  xlab("Time (hours)") 
```

## Check blank wells

By visualizing the black wells we can see that two of the blanks show evidence of cell growth suggesting contamination of those blanks. 

```{r}
ggplot(data_od_for_plot %>% filter(Sample == "B"), aes(time, od, color = well)) +
    geom_line() +
    #facet_grid(Sample~Bio_rep) +
    xlab("Time (hours)") +
    ggtitle("Blank wells")
```





## Individual Growth Profiles

We  plot the entire dataset arrayed in 96 well format it appears on the Tecan for visual inspection.  This allows us to easily identify any wells that should be excluded.

```{r}
data_od_for_plot %>%
  mutate(Sample_Well = str_replace(Sample_Well, "(?<![0-9])([0-9])(?![0-9])", "0\\1")) %>%
  ggplot(aes(time, od, color = as.factor(Bio_rep))) +
  geom_line() +
  facet_wrap(~Sample_Well, ncol=12) +
  xlab("Time (hours)")

```


# Remove outliers

Visual inspection of the data allows us to identify any wells that contain poorly behaving wells and remove them.  In this case two of our blank well, D1 and D6, show evidence for growth even though there was no inoculation indicating contamination.  Therefore, we remove these samples. 

```{r "specify-outliers"}
# wells to remove
outlier_wells = c('D1','D6')

#remove outliers
for(i in length(outlier_wells)) {
  data_od = data_od %>%
    select(!-!as.name(outlier_wells[i]))
}
```

# Using Growthcurver to fit curve data to logistic equation

The R package `Growthcurver` fits the growth rate data to the logistic equation below.
```{r}
knitr::include_graphics('logistic_eqn.png')
```


In this equation:

 * r is growth rate (units: hr^-1)
 * k is carrying capacity (units: OD)
 * N_0 is starting population size (units: OD)
 
From this equation several quantities are computed including:

 * t_gen, the fastest possible generation time (units: hr)  
 * t_mid is the time to half maximal k (units: hr)
 * sigma is a measure of the goodnesss of fit of the parameters
 * The area under the curve (AUC) for each sample, which integrates information from the logistic parameters (k, r, and N0)

The function `SummarizeGrowthByPlate`is used to fit the logistic regression to each growth profile.
By specifying `bg_correct = "blank"` the background OD is subtracted.

```{r include=T}
gc_out <- SummarizeGrowthByPlate(data_od, 
                                 plot_fit = FALSE) %>% 
  left_join(samplesheet, by = c("sample" = "Well")) %>%
  rename(well = sample, sample = Sample)

knitr::kable(gc_out)
```

# Pairwise correlations of parameters from logistic model

This makes clear that some of the parameters are independent (e.g. n0 and t_mid) whereas others are highly correlated (e.g. AUC and k).

```{r}
parameters <- gc_out %>% 
  filter(sample != "B")

panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- abs(cor(x, y))
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * r)
}

pairs(parameters[,2:8],lower.panel = panel.smooth, upper.panel = panel.cor,
      gap=0, row1attop=FALSE)
```


# Plot r, k, N0, t_gen, and sigma by sample

From the logistic regression fits we can plot the computed parameters for each model fit.

## Growth rate (r)

This shows that YPR results in a faster growth rate than Gln-lim and that S cerevisiae grows faster than C albicans.
```{r echo=T}
ggplot(gc_out %>% filter(sample != "B"), 
       aes(sample, r)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(aes(color = as.factor(Bio_rep)),dodge.width = 0.8) +
  ylab("growth rate (r) [hour^-1]")
```

## Carrying capacity (k)

This shows that S cerevisiae and C albicans arrest at similar final ODs in YPD but not Gln-lim media 
```{r}
ggplot(gc_out %>% filter(sample != "B"), 
       aes(sample, k)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(aes(color = as.factor(Bio_rep)),dodge.width = 0.8) +
  ylab("carrying capacity (k) [OD]")
```

## Initial population size (N0)

This suggests that C albicans started with a higher initial OD
```{r}
ggplot(gc_out %>% filter(sample != "B"), 
              aes(sample, n0)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(aes(color = as.factor(Bio_rep)),dodge.width = 0.8) +
  ylab("starting population size (N0) [OD]")
```

## Genertion time (ln(2) / r)

This shows that the generation time for YPD is shorter than for C albicans.
```{r}
ggplot(gc_out %>% filter(sample != "B"), 
              aes(sample, t_gen)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(aes(color = as.factor(Bio_rep)),dodge.width = 0.5) +
  ylab("generation time (hours)")
```

## Time to half maximal k (hours)

S. cerevisiae in YPD attains its half maximal population size fastest. 
```{r}
ggplot(gc_out %>% filter(sample != "B"), 
              aes(sample, t_mid)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(aes(color = as.factor(Bio_rep)),dodge.width = 0.5) +
  ylab("time to half maximal k")
```

## Area under the logistic curve

Determined by evaluating the definite integral of the fitted logistic equation
```{r}
ggplot(gc_out %>% filter(sample != "B"), 
              aes(sample, auc_l)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(aes(color = as.factor(Bio_rep)),dodge.width = 0.8) +
  ylab("Area under the logistic curve (AUC)")
```

## Area under the logistic curve - empirical

Determined by summing the areas of the trapezoids made up by connecting consecutive data points

```{r}
ggplot(gc_out %>% filter(sample != "B"), 
              aes(sample, auc_e)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(aes(color = as.factor(Bio_rep)),dodge.width = 0.8) +
  ylab("Emplirical area under the logistic curve (AUC)")
```
# Summarize by sample

By summarizing over samples we can compute the average of each parameter and the variance in the measurements.

```{r echo=T}
summary = gc_out %>% 
  filter(sample != "B") %>%
  group_by(sample) %>%
  summarise(mean_r = mean(r), var_r = var(r), mean_k = mean(k), var_k = var(k), 
            mean_generation_time = mean(t_gen), variance_generation_time =  var(t_gen)) 
summary %>%
  knitr::kable()
```
# Plot logistic fits over data

In order to visually inspect the quality of the model fits we plot the data and the fits.  

```{r echo=T}
#the following code is copied from the growthcurver vignette

d <- data_od %>% select(gc_out$well[which(gc_out$sample != "B")], time)

# Let's create an output data frame to store the results in. 
# We'll create it so that it is the right size (it's faster this way!), 
# but leave it empty.
num_analyses <- length(names(d)) - 1
d_gc <- data.frame(sample = character(num_analyses),
                   k = numeric(num_analyses),
                   n0  = numeric(num_analyses),
                   r = numeric(num_analyses),
                   t_mid = numeric(num_analyses),
                   t_gen = numeric(num_analyses),
                   auc_l = numeric(num_analyses),
                   auc_e = numeric(num_analyses),
                   sigma = numeric(num_analyses),
                   stringsAsFactors = FALSE)



# Now, loop through all of the columns in the data frame. For each column,
# run Growthcurver, save the most useful metrics in the output data frame,
# and make a plot of all the growth curve data and their best fits.

# First, create a plot for each of the wells in the 96-well plate.

# Uncomment the next line to save the plots from your 96-well plate to a 
# pdf file in the working directory.
#pdf("growthcurver.pdf", height = 8.5, width = 11)
par(mfrow = c(12,8))
par(mar = c(0.25,0.25,0.25,0.25))
y_lim_max <- max(d[,setdiff(names(d), "time")]) - min(d[,setdiff(names(d), "time")])

n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(d)) {
  
  # Don't process the column called "time". 
  # It contains time and not absorbance data.
  if (col_name != "time")  {

    # Create a temporary data frame that contains just the time and current col
    d_loop <- d[, c("time", col_name)]
    
# Do the background correction.
    
    # Background correction option 1: subtract the minimum value in a column
    #                                 from all measurements in that column
    min_value <- min(d_loop[, col_name])
    d_loop[, col_name] <- d_loop[, col_name] - min_value
   
    # Background correction option 2: subtract the mean value of blank wells
    #                                 over the course the experiment
    #                                 (Replace B2, D8, G11 with the column
    #                                  names of your media-only wells)
    #d$blank <- apply(d[, c("B2", "D8", "G11")], 1, mean)
    #d$A1 <- d$A1 - d$blank
    
    # Now, call Growthcurver to calculate the metrics using SummarizeGrowth
    gc_fit <- SummarizeGrowth(data_t = d_loop[, "time"], 
                              data_n = d_loop[, col_name],
                              bg_correct = "none")
    
    # Now, add the metrics from this column to the next row (n) in the 
    # output data frame, and increment the row counter (n)
    d_gc$sample[n] <- col_name
    d_gc[n, 2:9] <- c(gc_fit$vals$k,
                      gc_fit$vals$n0,
                      gc_fit$vals$r,
                      gc_fit$vals$t_mid,
                      gc_fit$vals$t_gen,
                      gc_fit$vals$auc_l,
                      gc_fit$vals$auc_e,
                      gc_fit$vals$sigma)
    n <- n + 1
    
    # Finally, plot the raw data and the fitted curve
    # Here, I'll just print some of the data points to keep the file size smaller
    n_obs <- length(gc_fit$data$t)
    idx_to_plot <- 1:20 / 20 * n_obs
    plot(gc_fit$data$t[idx_to_plot], gc_fit$data$N[idx_to_plot], 
         pch = 20, 
         #xlim = c(0, trim_at_time), 
         ylim = c(0, y_lim_max),
         cex = 0.6, xaxt = "n", yaxt = "n")
     text(x = 5, y = y_lim_max, labels = col_name, pos = 1)
     lines(gc_fit$data$t, predict(gc_fit$model), col = "red")
  }
}

```


# Output data

Write a csv files containing the results of the logistic fits for further analysis.

```{r echo=T}
write_csv(gc_out, paste0(filepath,out))
```

